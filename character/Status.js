// @ts-check
"use strict";

import { 整数乱数 } from "../Util.js";

export class 簡易ステータス {
  constructor(ＨＰ = 0, ＭＰ = 0, 攻撃力 = 0, 守備力 = 0, 素早さ = 0) {
    this.#ＨＰ = ＨＰ;
    this.#ＭＰ = ＭＰ;
    this.#攻撃力 = 攻撃力;
    this.#守備力 = 守備力;
    this.#素早さ = 素早さ;
  }

  get ＨＰ() { return this.#ＨＰ }
  get ＭＰ() { return this.#ＭＰ }
  get 攻撃力() { return this.#攻撃力 }
  get 守備力() { return this.#守備力 }
  get 素早さ() { return this.#素早さ }

  static ＨＰ(ＨＰ) {
    return new 簡易ステータス(ＨＰ, 0, 0, 0, 0);
  }

  static ＭＰ(ＭＰ) {
    return new 簡易ステータス(0, ＭＰ, 0, 0, 0);
  }

  static 攻撃力(攻撃力) {
    return new 簡易ステータス(0, 0, 攻撃力, 0, 0);
  }

  static 守備力(守備力) {
    return new 簡易ステータス(0, 0, 0, 守備力, 0);
  }

  static 素早さ(素早さ) {
    return new 簡易ステータス(0, 0, 0, 0, 素早さ);
  }

  static get ゼロ() {
    return this.#ゼロ;
  }

  static #ゼロ = new 簡易ステータス(0, 0, 0, 0, 0);
  #ＨＰ;
  #ＭＰ;
  #攻撃力;
  #守備力;
  #素早さ;
}

export class ステータス {
  constructor(ＨＰ = 0, ＭＰ = 0, 攻撃力 = 0, 守備力 = 0, 素早さ = 0, 現在ＨＰ = ＨＰ, 現在ＭＰ = ＭＰ, 現在攻撃力 = 攻撃力, 現在守備力 = 守備力, 現在素早さ = 素早さ) {
    this._ＨＰ = new 個別ステータス(ステータスの種類.消費系, ＨＰ, 現在ＨＰ);
    this._ＭＰ = new 個別ステータス(ステータスの種類.消費系, ＭＰ, 現在ＭＰ);
    this._攻撃力 = new 個別ステータス(ステータスの種類.能力系, 攻撃力, 現在攻撃力);
    this._守備力 = new 個別ステータス(ステータスの種類.能力系, 守備力, 現在守備力);
    this._素早さ = new 個別ステータス(ステータスの種類.能力系, 素早さ, 現在素早さ);
  }

  プレイヤー一覧用出力() {
    return [this.ＨＰ.基礎値, this.ＭＰ.基礎値, this.攻撃力.基礎値, this.守備力.基礎値, this.素早さ.基礎値];
  }

  ヘッダー用基礎値出力() {
    return 強調テキスト(
      " / ＨＰ ", this.ＨＰ.基礎値,
      " / ＭＰ ", this.ＭＰ.基礎値,
      " / 攻撃力 ", this.攻撃力.基礎値,
      " / 守備力 ", this.守備力.基礎値,
      " / 素早さ ", this.素早さ.基礎値
    );
  }

  ヘッダー用出力() {
    return 強調テキスト(
      "ＨＰ", this.ＨＰ.現在値, "/", this.ＨＰ.基礎値,
      " ＭＰ", this.ＭＰ.現在値, "/", this.ＭＰ.基礎値,
      " 攻撃力", this.攻撃力.現在値,
      " 守備力", this.守備力.現在値,
      " 素早さ", this.素早さ.現在値,
    );
  }

  ヘッダー用2ステータス出力() {
    return 強調テキスト(
      " ＨＰ：", this.ＨＰ.現在値, "/", this.ＨＰ.基礎値,
      " ＭＰ：", this.ＭＰ.現在値, "/", this.ＭＰ.基礎値,
    );
  }

  ヘッダー用3ステータス出力() {
    return 強調テキスト(
      "攻撃力 ", this.攻撃力.現在値,
      " / 守備力 ", this.守備力.現在値,
      " / 素早さ ", this.素早さ.現在値,
    );
  }

  一行出力() {
    return ` ＨＰ:${this.ＨＰ.現在値}/${this.ＨＰ.基礎値}, ＭＰ:${this.ＭＰ.現在値}/${this.ＭＰ.基礎値}, 攻撃力:${this.攻撃力.基礎値}, 守備力:${this.守備力.基礎値}, 素早さ:${this.素早さ.基礎値}`;
  }

  再計算(武器, 防具, 道具) {
    if (武器 !== undefined) {
      this.増加(武器.ステータスへ(), false);
    }
    if (防具 !== undefined) {
      this.増加(防具.ステータスへ(), false);
    }
    if (道具 instanceof 装備系道具) {
      this.増加(道具.ステータスへ(), false);
    }
    const 素早さ = this.素早さ;
    if (素早さ.現在値 < 0) {
      素早さ.現在値 = 0;
    }
  }

  増加(簡易ステータス, カンストチェックする = true) {
    const 上限 = カンストチェックする ? undefined : Infinity
    this.ＨＰ.現在値を設定(簡易ステータス.ＨＰ, 上限);
    this.ＭＰ.現在値を設定(簡易ステータス.ＭＰ, 上限);
    this.攻撃力.現在値を設定(簡易ステータス.攻撃力, 上限);
    this.守備力.現在値を設定(簡易ステータス.守備力, 上限);
    this.素早さ.現在値を設定(簡易ステータス.素早さ, 上限);
  }

  半減() {
    this.ＨＰ.基礎値 = Math.max(this.ＨＰ.基礎値 / 2, 転職時の最低ステータス.ＨＰ);
    this.ＭＰ.基礎値 = Math.max(this.ＭＰ.基礎値 / 2, 転職時の最低ステータス.ＭＰ);
    this.攻撃力.基礎値 = Math.max(this.攻撃力.基礎値 / 2, 転職時の最低ステータス.攻撃力);
    this.守備力.基礎値 = Math.max(this.守備力.基礎値 / 2, 転職時の最低ステータス.守備力);
    this.素早さ.基礎値 = Math.max(this.素早さ.基礎値 / 2, 転職時の最低ステータス.素早さ);
  }

  get ＨＰ() { return this._ＨＰ }
  get ＭＰ() { return this._ＭＰ }
  get 攻撃力() { return this._攻撃力 }
  get 守備力() { return this._守備力 }
  get 素早さ() { return this._素早さ }

  static オブジェクトから(オブジェクト) {
    return new ステータス(
      オブジェクト?._ＨＰ._基礎値, オブジェクト?._ＭＰ._基礎値, オブジェクト?._攻撃力._基礎値, オブジェクト?._守備力._基礎値, オブジェクト?._素早さ._基礎値,
      オブジェクト?._ＨＰ._現在値, オブジェクト?._ＭＰ._現在値, オブジェクト?._攻撃力._現在値, オブジェクト?._守備力._現在値, オブジェクト?._素早さ._現在値
    );
  }

  static ＨＰ() { return "ＨＰ"; }
  static ＭＰ() { return "ＭＰ"; }
  static 攻撃力() { return "攻撃力"; }
  static 守備力() { return "守備力"; }
  static 素早さ() { return "素早さ"; }
}


export class 個別ステータス {
  constructor(ステータスの種類, 基礎値, 現在値) {
    this.#ステータスの種類 = ステータスの種類;
    this._基礎値 = 基礎値;
    this._現在値 = 現在値;
  }

  基礎値を設定(基礎値, 上限値 = this.#ステータスの種類.上限) {
    this._基礎値 = Math.min(Math.trunc(基礎値), 上限値);
  }

  現在値を設定(現在値, 上限値 = this._基礎値 * this.#ステータスの種類.現在値上限係数) {
    this._現在値 = Math.min(Math.trunc(現在値), 上限値);
  }

  基礎値へ(割合 = 1) {
    this._現在値 = Math.trunc(this._基礎値 * 割合);
  }

  get 基礎値() { return this._基礎値; }
  set 基礎値(_基礎値) { this.基礎値を設定(_基礎値); }
  get 現在値() { return this._現在値; }
  set 現在値(_現在値) { this.現在値を設定(_現在値); }

  _基礎値;
  _現在値;
  #ステータスの種類;
}

export class 成長率 extends ステータス {
  成長結果一括取得(レベル) {
    const 成長 = new ステータス();
    for (let i = 0; i < レベル; i += 1) {
      成長.増加(this.成長取得(), false);
    }
    return 成長;
  }

  成長結果取得() {
    return 成長率.成長結果取得(this);
  }

  static 成長結果取得(最大成長値) {
    return new ステータス(
      this.#単独取得(最大成長値.ＨＰ) + 1,
      this.#単独取得(最大成長値.ＭＰ),
      this.#単独取得(最大成長値.攻撃力),
      this.#単独取得(最大成長値.守備力),
      this.#単独取得(最大成長値.素早さ)
    );
  }

  static #単独取得(最大成長値) {
    const 成長値 = 整数乱数(最大成長値);
    return 成長値 > 9 ? Math.floor(Math.random() * 9) + 1 : 成長値;
  }
}

class ステータスの種類 {
  constructor(上限, 現在値下限係数, 現在値上限係数) {
    this.#上限 = 上限;
    this.#現在値下限係数 = 現在値下限係数;
    this.#現在値上限係数 = 現在値上限係数;
  }

  get 上限() { return this.#上限; }
  get 現在値下限係数() { return this.#現在値下限係数; }
  get 現在値上限係数() { return this.#現在値上限係数; }

  static 消費系 = new ステータスの種類(999, 0.2, 1);
  static 能力系 = new ステータスの種類(255, 0.2, 2.5);
  static 命中率 = new ステータスの種類(95, 50 / 95, 1);

  #上限;
  #現在値下限係数;
  #現在値上限係数;
}
